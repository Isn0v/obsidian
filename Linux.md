
## Команды cli для работы с пользователями и группами

-  `id`
-  `chmod`
-  `chown`
-  `usermod`
-  `groupmod`
-  `users`
-  `groups`
-  `passwd`
-  `newgrp`

> В файле `/etc/passwd` лежит инфа о всех пользователях

## Boot process

Есть две последовательности инициализации Linux: boot и startup
- Boot - все события, начиная с нажатия кнопки включения и заканчивая инициализацией ядра и запуском `systemd`
- Startup - начиная с конца завершения boot и заканчивая введением компа в состояние, готовое для использования пользователем.
В целом, имеет смысл описать кратко boot стадию, но мне лень.

## Информация о системе
- `uptime` - вывод инфы 
	- о текущем времени
	- сколько комп был активен
	- о средних занятостях на cpu (load average - сколько процессов конкурировали за использование вычислительных ресурсов в среднем) за последние 1, 5, 10 минут
- `uname` - системная информация, среди которой
	- `-s` - имя ядра
	- `-n` - имя сетевого хоста(узла)
	- `-r` - релиз ядра
	- `-v` - версия ядра
	- `-m` - имя харддварной машины
	- `-p` - тип процессора
	- `-i` - платформа хардвара
	- `-o` - операционная система
	- `-a` - вся инфа выше, но вместе
- `lsb_release` - минимальная информация о дистрибутиве **(LSB - Linux Standart Base)**
	Имеет смысл делать в основном только с флагом `-a`. Альтернативный вариант команде - `cat /etc/os-release`
- `hostname` - вывод имени хоста, DNS, NIS/YP, FQDN
- `free` - количество свободной и используемой памяти на компе
- `vmstat` - статистика по виртуальной памяти
- `top` - выводит процессы Linux
- `htop` - аналог `top`, только интерактивный и более интуитивно понятный (иногда требует скачивания)
- `iotop` - I/O информация в стиле `top` команды
- `df` - 
- `du`

## Что происходит когда мы пишем что-то в терминале

1. Шелл читает, что мы написали в терминале `getline()`  и токенизирует `strtok()`
2. Смотрится первый аргумент, то есть название команды
	-  Это может быть встроенный алиас, встроенная функция или исполняемый файл, который резолвится в путь с использованием переменной `PATH`
3.  Нашли исполняемый файл. Вызываем `fork()` и в уже новом процессе, для которого шелл будет родителем, вызываем `execve()`, который развернет новое адресное пространство и выделит иные новые необходимые ресурсы под процесс
4. Команда начнет свое исполнение
> Промониторить и посмотреть детальные системные вызовы во время исполнения команды можно через `strace`. Например, `strace ls`

## Crash vs Panic

Crash - развал программы, вызванный хардваром или ОС вследствие, например, нехватки ресурсов
Panic - развал программы, вызванный вызовом функции `abort()` самой программой

## Proc Filesystem

Специальная виртуальная файловая система. В ней не хранятся настоящие файлы, тем не менее данные берутся из ядра в режиме реального времени, например, директории с номерами текущих активных процессов (*PID*)

## Troubleshooting Linux

Какие команды чаще всего используем.
Проблемные области:
1. Место на дисках
	- `df -h` - свободное место на дисках в читаемом для человека формате 
	- `du -sh /tmp` -  посмотреть сколько папка занимает места на диске
	- `df -i` - посмотреть количество inodes. Если занятых inodes 100%, то новые файлы нельзя будет создать даже если место на диске есть.
2. Состояние дисков
	- `lsblk` - вывести список блочных устройств
	- `smartctl -a /dev/nvme0n1` - информация о дисках через специальный интерфейс
3. Нагрузка на сервер (процессор, память)
	- `iostat` - общая информация о том, сколько на диск пишется и читается (может быть не установлена)
	- `iotop` - I/O информация в стиле `top` команды
	- `top` - мониторинг инфы по процессам и загрузке ЦП и памяти в реальном времени
4. Процессы
	- `ps aux` - все процессы, запущенные на сервере
	- Если процессы в ОС выполняются с помощью `systemd` (система инициализации и управления сервисами), то  можем использовать `systemctl status ...`
5. Сеть
	- `netstat -tulpn` - показывает процессы, которые слушают какие-то сетевые порты на сервере (может быть не установлена)
	- `ss -lntu` - примерно то же, что команда выше
	-  `ip a/ifconfig` - информация о сетевых интерфейсах
	- `ip r/netstat -rn` - информация о сетевых маршрутах
	- `ping 8.8.8.8` - диагностика доступности сети
	- `traceroute 8.8.8.8` - показывает путь пакетов от сервера отправителя до сервера получателя (может быть не установлена)
	- `mtr 8.8.8.8` - трассировка, как в `traceroute`, но в живом режиме
	- `dig/nslookup` - запросы к DNS серверу, проверять ответы, скорость
	- `dig @8.8.8.8 google.com` - использовать специфичный DNS
	- `dig -t aaaa google.com`  - запросить специфичный тип записи на DNS сервере. Данная команда запрашивает IPv6 адрес
	- `dig +trace google.com` - полный маршрут DNS запроса
	- `curl -Lv` - запрос к сайту, даже если сайт перемещен перманентно (301 код)
	- `curl -v telnet://<...>` - проверка доступности порта. Обычно `telnet` может не стоять на сервере, поэтому можно делать через `curl`
	- `curl --unix-socket /tmp/*.sock http://<...>` - проверка юникс сокета 
	- `tcpdump -v -i any port 443 -nn` - мониторинг входящих и исходящих пакетов через текущий хост
6. Логи
	Большинство логов живут в `/var/log/`
	- `tail -f /var/log/syslog` - системные логи
	- `/var/log/auth.log` - логи попыток входа на хост или выполнение команд с повышением привилегий
	- `/var/log/kern.log` - сообщения от ядра системы. Также можно посмотреть через `dmesg -T`, но тут сообщения от ядра начиная со старта системы
	- `journalctl -xeu <...>` - посмотреть логи какого-то сервиса, который управляется через `systemd`

